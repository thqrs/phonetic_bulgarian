<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <title>Transliterações</title>
    <style>

    /* General Element Styles */

    .material-icons {
        font-size: 24px; /* Adjust the size as needed */
        color: black; /* Change the color as desired */
    }

    hr {
        border: none;
        height: 1px;
        background-color: #ddd;
        margin: 0px 0;
    }

  /* Layout and Containers */
    .button-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background-color: white;
        z-index: 1000;

        display: flex;
        flex-wrap: wrap; /* Allow elements to wrap */
        justify-content: center;
        align-items: center;
        gap: 10px; /* Space between rows */
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .button-container button {
        position: relative; /* Needed for absolute positioning of child elements */
        padding: 10px; /* Adjust padding as needed */
        margin: 10px;
        background-color: #78C5EF;
        color: white;
        border: 1px solid #ccc;
        border-radius: 5px;
        box-sizing: border-box; /* Include padding and border in the width */
    }
    
   .button-container button span {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    .top-buttons, .audio-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: nowrap; /* Prevent wrapping within these containers */
        width: 100%; /* Full width to ensure each takes its own row */
        flex: 1 1 auto; /* Allow buttons to grow and shrink */

    }

.top-buttons, .audio-controls {
    display: flex;
    justify-content: stretch; /* Stretch buttons to fill the space */
    align-items: stretch; /* Stretch buttons vertically */
    flex-wrap: nowrap;
    width: 100%;
    height: auto; /* Adjust height based on content */
}

/* Base style for buttons */
.top-buttons button, .audio-controls button {
    flex-grow: 1;
    text-align: center;
    margin: 0;
    aspect-ratio: 1 / 1;
    padding: 0;
    box-sizing: border-box;
}

/* Media query for desktop screens */
@media (min-width: 100px) {
    .top-buttons button, .audio-controls button {
        max-width: 50px; /* Maximum width for buttons on desktop */
        max-height: 40px; /* Maximum height for buttons on desktop */
    }
}



    

    .file-selector-container {
        background-color: white;
        padding: 10px;
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
        z-index: 1000;
    }

    /* Specific Component Styles */
    .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
    }

    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
    }

    input:checked + .slider {
        background-color: #2196F3;
    }

    input:focus + .slider {
        box-shadow: 0 0 1px #2196F3;
    }

    input:checked + .slider:before {
        transform: translateX(26px);
    }

    .slider.round {
        border-radius: 34px;
    }

    .slider.round:before {
        border-radius: 50%;
    }

    /* Button Styles */
    button {
        flex: 0 0 auto;
        border-radius: 5px;
        border: 1px solid #ccc;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.2s;
        padding: 10px 15px;
        background-color: #78C5EF;
        color: white;
        font-size: 16px;
        text-align: center;
    }

    button:hover {
        background-color: #007baa;
        transform: scale(1.05);
    }

    button:active {
        transform: scale(0.95);
    }

    /* Additional Input Styles */
    input[type="range"], select {
        margin: 0 10px;
        border-radius: 5px;
    }

    /* Dark Mode Styles */
    .dark-mode {
        background-color: #111;
        color: white;
    }

    .dark-mode button {
        background-color: #444;
    }

    .dark-mode button:hover {
        background-color: #555;
    }

    .dark-mode .button-container, .dark-mode .file-selector-container {
        background-color: black;
        color: white;
    }

    .dark-mode textarea {
        background-color: #333;
        color: white;
        border: 1px solid white;
    }

    /* Chronometer Styles */
    .chronometer {
        position: fixed; /* Keep it fixed at the bottom */
        bottom: 0;
        left: 0;
        right: 0; /* Stretch across the bottom */
        background: #f0f0f0;
        padding: 10px;
        box-shadow: 0 -2px 5px rgba(0,0,0,0.2);
        text-align: center;
        z-index: 100000;
        font-family: 'Arial', sans-serif;
    }

    .chronometer span#timer {
        font-size: 24px;
        font-weight: bold;
    }

    .chronometer.exceeded, .chronometer.negative {
        background: #ff0000;
        color: #ffffff;
    }

    /* Content and Word Box Styles */
    #content {
        white-space: pre-wrap;
        word-wrap: break-word;
        line-height: 3em;
    }

    [class^="word-box"] {
        font-family: Arial, sans-serif; /* Specify your desired font-family here */
        font-size: 16px; 
        /* font-weight: bold; */
        background-color: rgba(220, 220, 220, 0.1); /* Light and subtle background */
        padding: 0.2em 0.5em 2em 0.5em; /* Keep vertical padding for height */
        border-radius: 2px; /* Less rounded corners */
        border: 1px solid rgba(0, 0, 0, 0.3); /* Subtle border */
        margin: 0 -7px 10px 0; /* Adjust margin as needed */
        display: inline-block;
        position: relative;
        line-height: 1.6; /* Maintain existing line height */
        color: #666; /* Lighter font color if needed */
    }


/*
    .word-box1 {
        background-color: rgba(135, 206, 250, 0.2);
    }

    .word-box2 {
        background-color: rgba(144, 238, 144, 0.2);
    }

    .word-box3 {
        background-color: rgba(135,206,250, 0.5)
    }
*/
    .transliteration {
        position: absolute;
        bottom: 0.2em;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1em;
    }
    #boxContainer {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 50%; /* One-third of the page height */
        background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent black */
        color: white;
        overflow-y: auto; /* Add scroll for overflow */
        padding: 20px;
        box-sizing: border-box;
    }
.audio-timeline {
    display: flex;
    align-items: center; /* Vertical centering */
    gap: 10px; /* Adjust as needed for spacing */
}

.timestamps {
    display: flex;
    align-items: center; /* Ensure timestamps are also centered */
}

    </style>
</head>
<body>

<div class="button-container">
    <div class="audio-controls">
        <!-- Audio player section -->
        <audio id="audioPlayer" src="perolas.mp3" preload="metadata"></audio>


    <button id="playPauseButton" onclick="togglePlayPause()"><span class="material-icons">play_arrow</span></button>
    <button onclick="stopAudio()"><span class="material-icons">stop</span></button>
   

        
       <div class="audio-timeline">
    <input id="seekBar" type="range" min="0" max="100" value="0" step="1" oninput="updateAudioTime()" onchange="updateAudioTime()"/>
    <div class="timestamps">
        <span id="currentTime">0:00</span>/<span id="totalTime">0:00</span>
    </div>
</div>
        
        <!-- Dropdown for playback speed -->
        <label for="speedControl"><span></span></label>
        <select id="speedControl" onchange="changePlaybackSpeed()">
            <option value="1">1x</option>
            <option value="0.9">0.9x</option>
            <option value="0.8">0.8x</option>
            <option value="0.7">0.7x</option>
            <option value="0.6">0.6x</option>
            <option value="0.5">0.5x</option>
            <option value="0.4">0.4x</option>
            <option value="0.3">0.3x</option>
            <option value="0.2">0.2x</option>
            <option value="0.1">0.1x</option>
        </select>
    </div>
</div>



</div>

<div style="clear: both;"></div> 
<div id="content"></div>
    


<div id="boxContainer" style="display: none;">
        <div class="top-buttons">
            
        <button id="increaseMargin" onclick="adjustMargin(-1)"><span class="material-icons">expand_less</span></button>
        <button id="decreaseMargin" onclick="adjustMargin(1)"><span class="material-icons">expand_more</span></button>
        <button id="decreaseHorizontalMargin" onclick="adjustHorizontalMargin(-1)"><span class="material-icons">fast_rewind</span></button>
        <button id="increaseHorizontalMargin" onclick="adjustHorizontalMargin(1)"><span class="material-icons">fast_forward</span></button>
        <button id="increaseFontSize" onclick="adjustFontSize(1.1)"><span class="material-icons">add</span></button>
        <button id="decreaseFontSize" onclick="adjustFontSize(0.9)"><span class="material-icons">remove</span></button>
        <button id="toggleDarkMode" onclick="toggleDarkMode()"><span class="material-icons">invert_colors</span></button>

            
              </div>
                <div class="clipboard-container">
                    <h3>Искам Да Използвам Текст, Написан От Мен:</h3>
                    <h4>Quero Usar Um Texto Escrito Por Mim:</h4>
                <textarea id="pasteBox" rows="3" cols="40" placeholder="Въведете текста тук и натиснете ''Обработвай! (Escrever o texto aqui e carregar em ''Обработвай!'')"></textarea>
            </div><div>
            <button id="processPastedContent" onclick="processPastedContent()">
                Обработвай! <span class="material-icons">done</span>
            </button>
            </div>
            
            <div id="extrabuttons"></div>
                <h3>Искам Да Използвам Текст, Който Съм Копирал:</h3>
                    <h4>Quero Usar Um Texto Que Eu Copiei:</h4>
                <button id="pasteFromClipboard" onclick="processClipboardContent()">
                Обработка На Копирания Текст! <span class="material-icons">content_paste</span><span class="material-icons">settings</span>
            </button>

                <!-- <button onclick="handleClipboard()">Fetch from Clipboard</button> -->

            
                
                <div>
                <h3>Думи, Които Бяха Автоматично Транслитерирани:</h3>
                    <h4>Palavras Que Foram Transliteradas Automaticamente:</h4>
                <textarea id="missingTransliterationsBox" rows="3" cols="40">placeholder="Palavras que não estão na base de dados aparecerão aqui..."></textarea>
                    </div>
                    <div>
                <button onclick="copyMissingTransliterations()">Копирай</button>
            </div>
            
            
            <!-- Dropdown for file selection -->
                <div>
                <h3>"Изберете Един От Предефинираните Тестови Текстове:</h3>
                    <h4>Selecionar Texto de Teste Predefinido:</h4>
                </div>
               
            <div class="file-selector-container">
                <select id="fileSelector" onchange="loadSelectedFile()">
                    <!-- Options will be populated by JavaScript -->
                </select>
            
            </div>
                <div><h3>Разстояние На Маржовете:</h3>
                    <h4>Espaçamento das Margens:</h4>
                       <span id="verticalMarginDisplay">10px</span>   <!-- This is the initial vertical margin -->
               <span id="horizontalMarginDisplay">5px</span>  <!-- This is the initial horizontal margin -->
            
            
            </div><div>
                <h3>Промяна На Фоновата Цвят:</h3>
                   <h4> Modificar a Cor de Fundo:</h4>
                <p>Въведете цвета за фона на страницата в хексадецимален формат: '#FF0000', RGB (Червено, Зелено, Синьо): 'rgb(255,0,0)', или на английски: 'white'.
                    </br>
            </br>
                Introduzir a cor para o fundo da página: '#FF0000', 'rgb(255,0,0)', ou 'white'</p>
            <input type="text" id="colorInput" placeholder="Introduzir cor do fundo: '#FF0000', 'rgb(255,0,0)', ou 'white'">
                <button onclick="changeBackgroundColor()">
                <span class="material-icons">palette</span>
                </button>

            </div>
            
            <div style="margin-top: 20px; border-top: 1px solid #ccc; padding-top: 20px;">
                <p>&copy; 2023 Tiago Henriques. Esta obra está licenciada com uma Licença <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener noreferrer">Creative Commons Atribuição-NãoComercial 4.0 Internacional</a>.</p>
                <p>Para perguntas, entre em contacto: resourceful.motion(at)gmail.com</p>
                <img src="https://licensebuttons.net/l/by-nc/4.0/88x31.png" alt="Creative Commons Atribuição-NãoComercial 4.0 Internacional">
            </div>
</div>

        <!-- Chronometer Section -->
        <div id="chronometer" class="chronometer">
            <span id="timer" onclick="toggleTimerMode()">време: 00:00</span>
        <br>
        <button id="loadAllTransliterations" onclick="showAllTransliterations()">
            <span class="material-icons">chat</span>
        </button>
        <button id="clearAllTransliterations" onclick="clearAllTransliterations()">
            <span class="material-icons">clear</span>
        </button>
        
        <button onclick="startTimer()">
            <span class="material-icons">timer</span>
        </button>
        <button onclick="stopResetTimer()">
            <span class="material-icons">sync</span>
        </button>
        <label class="switch">
            <input type="checkbox" id="modeToggle" onchange="toggleTimerMode()">
            <span class="slider round"></span>
        </label>
        <button id="showBoxButton">
            <span class="material-icons">settings</span>
        </button>



 

<script>

    let audioPlayer = document.getElementById('audioPlayer');
let seekBar = document.getElementById('seekBar');
let currentTimeDisplay = document.getElementById('currentTime');
let totalTimeDisplay = document.getElementById('totalTime');

audioPlayer.addEventListener('loadedmetadata', function() {
    seekBar.max = audioPlayer.duration;
    seekBar.value = 0;  // Ensure the seek bar starts at the beginning
    totalTimeDisplay.textContent = formatTime(audioPlayer.duration);
});

audioPlayer.addEventListener('timeupdate', function() {
    seekBar.value = audioPlayer.currentTime;
    currentTimeDisplay.textContent = formatTime(audioPlayer.currentTime);
});
    
let playPauseButton = document.getElementById('playPauseButton');

function togglePlayPause() {
    var playPauseIcon = document.getElementById('playPauseButton').querySelector('.material-icons');
    if (audioPlayer.paused || audioPlayer.ended) {
        audioPlayer.play();
        playPauseIcon.innerText = 'pause'; // Change icon to pause symbol
    } else {
        audioPlayer.pause();
        playPauseIcon.innerText = 'play_arrow'; // Change icon to play symbol
    }
}

function stopAudio() {
    audioPlayer.pause();
    audioPlayer.currentTime = 0;
    var playPauseIcon = document.getElementById('playPauseButton').querySelector('.material-icons');
    playPauseIcon.innerText = 'play_arrow'; // Reset to play symbol
}
function updateAudioTime() {
    audioPlayer.currentTime = seekBar.value;
}

function formatTime(time) {
    let mins = Math.floor(time / 60);
    let secs = Math.floor(time % 60);
    return mins + ':' + (secs < 10 ? '0' : '') + secs;
}
    
function changePlaybackSpeed() {
    var audioPlayer = document.getElementById('audioPlayer');
    var speed = document.getElementById('speedControl').value;
    audioPlayer.playbackRate = parseFloat(speed);
}
    
 if (!localStorage.getItem('verticalMargin')) {
    localStorage.setItem('verticalMargin', '10px');
}

if (!localStorage.getItem('horizontalMargin')) {
    localStorage.setItem('horizontalMargin', '5px');
}
// Call the function to load saved margins on page load
loadMargins();
    
function handleClipboard() {
    if (!navigator.clipboard) {
        alert("Clipboard API not supported in this browser.");
        return;
    }

    navigator.clipboard.readText()
        .then(text => {
            if (text) {
                displayTextFromContent(text);
            } else {
                alert('Clipboard is empty.');
            }
        })
        .catch(err => {
            console.error('Failed to read clipboard:', err);
            alert("Failed to access clipboard. Ensure permissions are granted.");
        });
}
    
function loadNewTransliterations(callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'commontransliterations.json', true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                callback(JSON.parse(xhr.responseText));
            } else {
                console.error("Error loading commontransliterations.json:", xhr.statusText);
            }
        }
    };
    xhr.send();
}

    function changeBackgroundColor() {
    const colorValue = document.getElementById('colorInput').value;
    document.body.style.backgroundColor = colorValue;
}
    function adjustFontSize(multiplier) {
    let contentDiv = document.getElementById('content');
    // Get the current font size of the content
    let currentSize = window.getComputedStyle(contentDiv, null).getPropertyValue('font-size');
    let newSize = parseFloat(currentSize) * multiplier;  // Adjust the font size
    contentDiv.style.fontSize = `${newSize}px`;  // Set the new font size

    // Display the new size without 'px' (Assuming there's a display element for this, e.g., a div or span)
    let displayBox = document.getElementById('fontSizeDisplay');  // Assuming there's an element with this ID
    if (displayBox) {
        displayBox.textContent = newSize.toFixed(2);  // Display without 'px', rounded to two decimal places
    }
}
    function changeBackgroundColor() {
    const colorInput = document.getElementById('colorInput');
    let selectedColor;
const shadesOfGray = [
    "#f5f5f5",
    "#e0e0e0",
    "#d6d6d6",
    "#b0b0b0",
    "#a1a1a1",
    "#8c8c8c",
    "#707070",
    "#5c5c5c",
    "#474747",
    "#333333"
];
    // If the input box is empty
    if (!colorInput.value.trim()) {
        // Pick a random index from the shadesOfGray array
        const randomIndex = Math.floor(Math.random() * shadesOfGray.length);
        selectedColor = shadesOfGray[randomIndex];

        // Update the input box value with the chosen shade of gray
        colorInput.value = selectedColor;
    } else {
        // Use the specified color
        selectedColor = colorInput.value;
    }

    // Set the selected color as the background color
    document.body.style.backgroundColor = selectedColor;
}
    // Function to populate the dropdown
function populateDropdown(files) {
    const selector = document.getElementById('fileSelector');
    files.forEach(file => {
        let option = document.createElement('option');
        option.value = file;
        option.textContent = file;
        selector.appendChild(option);
    });
}
function toggleDarkMode() {
    let bodyElement = document.body;
    
    if (bodyElement.classList.contains('dark-mode')) {
        bodyElement.classList.remove('dark-mode');
    } else {
        bodyElement.classList.add('dark-mode');
    }
}
// Function to load the list of .txt files
function loadFileList() {
    fetch('files.json')
        .then(response => response.json())
        .then(data => {
            populateDropdown(data.files);

            if (data.files.length > 0) {
                // Set the initial text and audio file based on the first item in the list
                let firstFile = data.files[0];
                let baseFileName = firstFile.split('.')[0];
                audioPlayer.src = baseFileName + '.mp3';

                // Load the text from the first file
                displayText(firstFile);
            }
        })
        .catch(error => console.error("Error loading files list:", error));
}


function loadSelectedFile() {
    let selectedFile = document.getElementById('fileSelector').value;
    displayText(selectedFile);  // Continue to load the text as before

    // Extract the base file name without the extension
    let baseFileName = selectedFile.split('.')[0];

    // Update the audio player source
    audioPlayer.src = baseFileName + '.mp3';
    audioPlayer.load(); // Reload the audio player with the new source
    stopAudio()
}

loadFileList();  // Call the function to load the file list

    
 // Load the text from filename
  function loadText(filename, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', filename, true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                callback(xhr.responseText);
            } else {
                console.error("Error loading " + filename + ":", xhr.statusText);
            }
        }
    };
    xhr.send();
}

    // Load the transliterations from transliterations.json
    function loadTransliterations(callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', 'transliterations.json', true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                if (xhr.status == 200) {
                    callback(JSON.parse(xhr.responseText));
                } else {
                    console.error("Error loading transliterations.json:", xhr.statusText);
                }
            }
        };
        xhr.send();
    }

function toggleTransliteration(element) {
    let translitElem = element.querySelector('.transliteration');
    let transliteration = element.getAttribute('data-transliteration');

    if (!translitElem && transliteration) {
        translitElem = document.createElement('div');
        translitElem.className = 'transliteration';
        translitElem.textContent = transliteration;
        element.appendChild(translitElem);
    } else if (translitElem) {
        if (translitElem.style.display !== 'none') {
            translitElem.style.display = 'none';
        } else {
            translitElem.style.display = 'block';
        }
    }
}

    function showAllTransliterations() {
    let wordBoxes = document.querySelectorAll('.word-box1, .word-box2, .word-box3'); // Target both classes
    wordBoxes.forEach(box => {
        let transliteration = box.getAttribute('data-transliteration');
        if (transliteration) {
            let translitElem = box.querySelector('.transliteration');
            if (!translitElem) {
                translitElem = document.createElement('div');
                translitElem.className = 'transliteration';
                translitElem.textContent = transliteration;
                box.appendChild(translitElem);
            } else {
                translitElem.style.display = 'block';
            }
        }
    });
}


    function clearAllTransliterations() {
    let translitElements = document.querySelectorAll('.transliteration');
    translitElements.forEach(elem => {
        elem.style.display = 'none';
    });
}


   let missingTransliterations = [];

let newTransliterations = {};

function displayText(filename = 'perolas.txt') {  
    loadText(filename, function(text) {
        if (!text) {
            console.error("No text loaded from", filename);
            return;
        }

        loadTransliterations(function(transliterations) {
            loadNewTransliterations(function(newTrans) {
                newTransliterations = newTrans;

                if (!transliterations) {
                    console.error("No transliterations loaded");
                    return;
                }

                // Split the text into segments to process for $$ and other elements
                let htmlContent = '';
                let inHtmlBlock = false;
                text.split(/(\$\$|\s+|\n+)/).forEach(segment => {
                    // Toggle the inHtmlBlock flag when encountering $$
                    if (segment === '$$') {
                        inHtmlBlock = !inHtmlBlock;
                        return;
                    }

                    // If inside a $$ block, append the HTML directly
                    if (inHtmlBlock) {
                        htmlContent += segment;
                    } else {
                        // Process non-HTML segments for images, transliterations, etc.
                        if (segment.trim() === '') {
                            htmlContent += segment;
                        } else {
                            const imageRegex = /#(.*?\.(png|jpg|jpeg|gif|bmp))#/;
                            const match = segment.match(imageRegex);
                            if (match) {
                                const imageUrl = match[1];
                                htmlContent += `<img src="https://raw.githubusercontent.com/thqrs/phonetic_bulgarian/main/${imageUrl}" alt="Image" style="max-width:100%; height:auto;">`;
                            } else {
                                let cleanSegment = segment.toLowerCase().replace(/[\n,.\d:;?!‘’]/g, '');
                                if (transliterations[cleanSegment]) {
                                    htmlContent += `<span class="word-box1" data-transliteration="${transliterations[cleanSegment]}" onclick="toggleTransliteration(this)">${segment}</span>`;
                                } else if (newTransliterations[cleanSegment]) {
                                    htmlContent += `<span class="word-box2" data-transliteration="${newTransliterations[cleanSegment]}" onclick="toggleTransliteration(this)">${segment}</span>`;
                                } else {
                                    if (cleanSegment.trim() !== '') {
                                        missingTransliterations.push(cleanSegment);
                                    }
                                    htmlContent += `<span class="word-box3" data-transliteration="${getDummyTransliteration(cleanSegment)}" onclick="toggleTransliteration(this)">${segment}</span>`;
                                }
                            }
                        }
                    }
                });

                document.getElementById('content').innerHTML = htmlContent;
                updateMissingTransliterations();
            });
        });
    });
}




    function processClipboardContent() {
    navigator.clipboard.readText().then(text => {
        if (text) {
            displayTextFromContent(text);
        } else {
            alert('Clipboard is empty.');
        }
    }).catch(err => {
        console.error('Failed to read clipboard:', err);
    });
}

function processPastedContent() {
    const text = document.getElementById('pasteBox').value;
    if (text) {
        displayTextFromContent(text);
    } else {
        alert('Paste box is empty.');
    }
}

function displayTextFromContent(text) {
    if (!text) {
        console.error("No text provided");
        return;
    }
    
    loadTransliterations(function(transliterations) {
        loadNewTransliterations(function(newTrans) {
            newTransliterations = newTrans;
            
            if (!transliterations) {
                console.error("No transliterations loaded");
                return;
            }

            let htmlContent = text.split(/(\s+|\n+)/).map(segment => {
                if (segment === '\n' || /^\s+$/.test(segment)) {
                    return segment;
                }
                let cleanSegment = segment.toLowerCase().replace(/[\n,.\d:;?!‘’]/g, '');
                
                if (transliterations[cleanSegment]) {
                    return `<span class="word-box1" data-transliteration="${transliterations[cleanSegment]}" onclick="toggleTransliteration(this)">${segment}</span>`;
                } 
                else if (newTransliterations[cleanSegment]) {
                    return `<span class="word-box2" data-transliteration="${newTransliterations[cleanSegment]}" onclick="toggleTransliteration(this)">${segment}</span>`;
                }
                else {
                    if (cleanSegment.trim() !== '') {
                        missingTransliterations.push(cleanSegment);
                    }
                    return `<span class="word-box3" data-transliteration="${getDummyTransliteration(cleanSegment)}" onclick="toggleTransliteration(this)">${segment}</span>`;
                }
            }).join('');

            document.getElementById('content').innerHTML = htmlContent;
            updateMissingTransliterations();
        });
    });
}


function updateMissingTransliterations() {
    let uniqueMissing = [...new Set(missingTransliterations)];  // Remove duplicates
    document.getElementById('missingTransliterationsBox').value = uniqueMissing.join('\n');
}

function copyMissingTransliterations() {
    let copyText = document.getElementById("missingTransliterationsBox");
    copyText.select();
    document.execCommand("copy");
}

  function loadMappings(callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'mappings.json', true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                callback(JSON.parse(xhr.responseText));
            } else {
                console.error("Error loading mappings.json:", xhr.statusText);
            }
        }
    };
    xhr.send();
}
let phonemeMappings = {};

function getDummyTransliteration(word) {
    let transliterated = word;

    // Apply the mappings using regular expressions
    for (let [portuguese, bulgarian] of Object.entries(phonemeMappings)) {
        let regex = new RegExp(portuguese, 'g');
        transliterated = transliterated.replace(regex, bulgarian);
    }

    return transliterated;
}

loadMappings(function(mappings) {
    phonemeMappings = mappings;
});

displayText();

    
document.addEventListener("DOMContentLoaded", function() {
    adjustHorizontalMargin(5);
    adjustMargin(10);
});
    function adjustMargin(point) {
        console.log("Adjusting vertical margin...");
    let wordBoxes = document.querySelectorAll('[class^="word-box"]');
    let newMargin;
    wordBoxes.forEach(box => {
        let currentMargin = window.getComputedStyle(box, null).getPropertyValue('margin-bottom');
        newMargin = (parseFloat(currentMargin) + point) + 'px';
        box.style.marginBottom = newMargin;
    });
    document.getElementById('verticalMarginDisplay').textContent = newMargin;
        localStorage.setItem('verticalMargin', newMargin);
        console.log("Saved verticalMargin:", localStorage.getItem('verticalMargin'));
        console.log("Vertical margin adjusted.");
        

}

function adjustHorizontalMargin(point) {
        console.log("Adjusting horizontal margin...");

    let wordBoxes = document.querySelectorAll('[class^="word-box"]');
    let newMarginRight;
    wordBoxes.forEach(box => {
        let currentMarginRight = window.getComputedStyle(box, null).getPropertyValue('margin-right');
        newMarginRight = (parseFloat(currentMarginRight) + point) + 'px';
        box.style.marginRight = newMarginRight;
    });
    document.getElementById('horizontalMarginDisplay').textContent = newMarginRight;
    localStorage.setItem('horizontalMargin', newMarginRight);
    console.log("Saved horizontalMargin:", localStorage.getItem('horizontalMargin'));

    console.log("Horizontal margin adjusted.");
}
    function loadMargins() {
    let savedVerticalMargin = localStorage.getItem('verticalMargin');
    let savedHorizontalMargin = localStorage.getItem('horizontalMargin');

    if (savedVerticalMargin && savedVerticalMargin !== "undefined") {
        let wordBoxes = document.querySelectorAll('[class^="word-box"]');
        wordBoxes.forEach(box => {
            box.style.marginBottom = savedVerticalMargin;
        });
        document.getElementById('verticalMarginDisplay').textContent = savedVerticalMargin;
    }

    if (savedHorizontalMargin && savedHorizontalMargin !== "undefined") {
        let wordBoxes = document.querySelectorAll('[class^="word-box"]');
        wordBoxes.forEach(box => {
            box.style.marginRight = savedHorizontalMargin;
        });
        document.getElementById('horizontalMarginDisplay').textContent = savedHorizontalMargin;
    }
}

let timerInterval;
let elapsedTime = 0; // Immutable elapsed time
let countdown = false;
let appointedMinutes = 10;
let startTime;
    
function toggleTimerMode() {
    countdown = document.getElementById('modeToggle').checked;
    updateTimerDisplay();
}



function updateTimerDisplay() {
    let displayTime;
    let timeLabel;
    let chronometerElement = document.getElementById('chronometer');

    if (countdown) {
        // Calculate the remaining or elapsed time for countdown
        displayTime = appointedMinutes * 60 - elapsedTime;
        timeLabel = "Оставащо време"; // Remaining Time in Bulgarian

        // Add a class to change color if time is negative
        if (displayTime < 0) {
            chronometerElement.classList.add('negative');
        } else {
            chronometerElement.classList.remove('negative');
        }
    } else {
        // In stopwatch mode, display the elapsed time
        displayTime = elapsedTime;
        timeLabel = "Общо време"; // Total Time in Bulgarian
        chronometerElement.classList.remove('negative');
    }

    let minutes = Math.floor(Math.abs(displayTime) / 60);
    let seconds = Math.abs(displayTime % 60);
    seconds = seconds < 10 ? "0" + seconds : seconds;

    let timerText = countdown && displayTime < 0 ? '-' : '';
    timerText += `${timeLabel}: ${minutes}:${seconds}`;
    document.getElementById('timer').textContent = timerText;
}




function startTimer() {
    if (!timerInterval) {  // Check if the timer is not already running
        startTime = Date.now() - elapsedTime * 1000; // Adjust startTime based on elapsedTime
        timerInterval = setInterval(() => {
            elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            updateTimerDisplay();
        }, 1000);
    }
}

function stopResetTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
    elapsedTime = 0; // Reset the elapsed time
    updateTimerDisplay();
}

// Initial update
updateTimerDisplay();

document.getElementById('showBoxButton').addEventListener('click', function() {
    var box = document.getElementById('boxContainer');
    box.style.display = box.style.display === 'none' ? 'block' : 'none';
});
    
function adjustContentMargin() {
    var buttonContainerHeight = document.querySelector('.button-container').offsetHeight;
    var contentDiv = document.getElementById('content');
    contentDiv.style.marginTop = buttonContainerHeight + 'px';
}

// Adjust margin on page load
window.onload = adjustContentMargin;

// Adjust margin on window resize
window.onresize = adjustContentMargin;

    
</script>

</body>
</html>
